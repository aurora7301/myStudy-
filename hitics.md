 

 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps116.png) 

 

***\*计算机系统\****

 

***\*大作业\****

 

 

题   目 程序人生-Hello’s P2P	 

专    业   计算学部          

学　　  号   120L021520          

班　　  级   2003012          

学    生   臧德阳       　　

指 导 教 师   郑贵滨        　　

 

 

 

 

 

 

***\*计算机科学与技术学院\****

***\*2021年5月\****

***\*摘  要\****

本文基于IntelCorei5处理器和Linux操作系统，分析了Hello程序从hello.c源代码经过预处理、编译、汇编、链接、运行、终止的全过程，阐述了操作系统对Hello程序的进程管理、存储管理、I/O管理，将计算机系统的各方面知识整合，更好地阐明了程序的整个生命周期。

 

***\*关键词：\****计算机系统；程序生命周期；操作系统***\*；\**** 虚拟内存；进程；              

 

***\*（摘要0分，缺失-1分，\*******\*根据内容精彩称都酌情加分0-1分\*******\*）\****

 

 

 

 

 

 

 

***\*
\****

***\*目  录\****

 

[第1章 概述	***\*- 4 -\****](#_Toc532238396)

[1.1 Hello简介	- 4 -](#_Toc532238397)

[1.2 环境与工具	- 4 -](#_Toc532238398)

[1.3 中间结果	- 4 -](#_Toc532238399)

[1.4 本章小结	- 4 -](#_Toc532238400)

[第2章 预处理	***\*- 5 -\****](#_Toc532238401)

[2.1 预处理的概念与作用	- 5 -](#_Toc532238402)

[2.2在Ubuntu下预处理的命令	- 5 -](#_Toc532238403)

[2.3 Hello的预处理结果解析	- 5 -](#_Toc532238404)

[2.4 本章小结	- 5 -](#_Toc532238405)

[第3章 编译	***\*- 6 -\****](#_Toc532238406)

[3.1 编译的概念与作用	- 6 -](#_Toc532238407)

[3.2 在Ubuntu下编译的命令	- 6 -](#_Toc532238408)

[3.3 Hello的编译结果解析	- 6 -](#_Toc532238409)

[3.4 本章小结	- 6 -](#_Toc532238410)

[第4章 汇编	***\*- 7 -\****](#_Toc532238411)

[4.1 汇编的概念与作用	- 7 -](#_Toc532238412)

[4.2 在Ubuntu下汇编的命令	- 7 -](#_Toc532238413)

[4.3 可重定位目标elf格式	- 7 -](#_Toc532238414)

[4.4 Hello.o的结果解析	- 7 -](#_Toc532238415)

[4.5 本章小结	- 7 -](#_Toc532238416)

[第5章 链接	***\*- 8 -\****](#_Toc532238417)

[5.1 链接的概念与作用	- 8 -](#_Toc532238418)

[5.2 在Ubuntu下链接的命令	- 8 -](#_Toc532238419)

[5.3 可执行目标文件hello的格式	- 8 -](#_Toc532238420)

[5.4 hello的虚拟地址空间	- 8 -](#_Toc532238421)

[5.5 链接的重定位过程分析	- 8 -](#_Toc532238422)

[5.6 hello的执行流程	- 8 -](#_Toc532238423)

[5.7 Hello的动态链接分析	- 8 -](#_Toc532238424)

[5.8 本章小结	- 9 -](#_Toc532238425)

[第6章 hello进程管理	***\*- 10 -\****](#_Toc532238426)

[6.1 进程的概念与作用	- 10 -](#_Toc532238427)

[6.2 简述壳Shell-bash的作用与处理流程	- 10 -](#_Toc532238428)

[6.3 Hello的fork进程创建过程	- 10 -](#_Toc532238429)

[6.4 Hello的execve过程	- 10 -](#_Toc532238430)

[6.5 Hello的进程执行	- 10 -](#_Toc532238431)

[6.6 hello的异常与信号处理	- 10 -](#_Toc532238432)

[6.7本章小结	- 10 -](#_Toc532238433)

[第7章 hello的存储管理	***\*- 11 -\****](#_Toc532238434)

[7.1 hello的存储器地址空间	- 11 -](#_Toc532238435)

[7.2 Intel逻辑地址到线性地址的变换-段式管理	- 11 -](#_Toc532238436)

[7.3 Hello的线性地址到物理地址的变换-页式管理	- 11 -](#_Toc532238437)

[7.4 TLB与四级页表支持下的VA到PA的变换	- 11 -](#_Toc532238438)

[7.5 三级Cache支持下的物理内存访问	- 11 -](#_Toc532238439)

[7.6 hello进程fork时的内存映射	- 11 -](#_Toc532238440)

[7.7 hello进程execve时的内存映射	- 11 -](#_Toc532238441)

[7.8 缺页故障与缺页中断处理	- 11 -](#_Toc532238442)

[7.9动态存储分配管理	- 11 -](#_Toc532238443)

[7.10本章小结	- 12 -](#_Toc532238444)

[第8章 hello的IO管理	***\*- 13 -\****](#_Toc532238445)

[8.1 Linux的IO设备管理方法	- 13 -](#_Toc532238446)

[8.2 简述Unix IO接口及其函数	- 13 -](#_Toc532238447)

[8.3 printf的实现分析	- 13 -](#_Toc532238448)

[8.4 getchar的实现分析	- 13 -](#_Toc532238449)

[8.5本章小结	- 13 -](#_Toc532238450)

[结论	***\*- 14 -\****](#_Toc532238451)

[附件	***\*- 15 -\****](#_Toc532238452)

[参考文献	***\*- 16 -\****](#_Toc532238453)

 

 

# ***\* \*******\*第1章\**** ***\*概述\****

## 1.1 Hello简介

根据Hello的自白，利用计算机系统的术语，简述Hello的P2P，020的整个过程。

\1. P2P（From Program to Process）指从程序到进程。我们使用I/O设备编写源代码hello.c（program）并存储在磁盘中，运行时被加载到内存中。经过预处理器cpp（C Pre-Processor）进行预处理，删除了注释、插入库函数、替换宏定义，生成文本文件hello.i；hello.i继续经过编译器ccl（c compiler），编译器对它进行词法、语法语义分析，编译生成汇编文件hello.s；hello.s经过汇编器as（assembler）生成ELF格式的机器语言文件hello.o，包含各种重定位条目、符号表、数据段、代码段等等；hello.o通过链接器ld与其他所需的可重定位目标文件、共享库链接生成可执行文件hello，可执行文件中包含了程序运行时状态机所需的全部信息。在Linux系统的shell中输入命令(./hello )后,OS进行fork创建子进程process，子进程进行系统调用execve将子进程的状态机替换为可执行文件hello的状态机。shell系统调用mmap函数构建虚拟内存映射，操作系统内核和硬件包括寄存器、MMU(memory management unit)、TLB、页表、cache完成快速完成内存的翻译、访问和加速。内核通过上下文切换调度hello进程并为hello进程分配时间片，使得hello进程和OS中的其他进程交替运行。如果进程出现异常，硬件和操作系统会触发控制转移到异常处理程序。hello进程也要处理各种信号，信号从操作系统内核发送到一个进程，目的进程对信号做出反应。

\2. 020（From Zero to Zero）指的是hello程序执行前，不占用内存内存空间。进行P2P后，子进程执行execve系统调用，进行虚拟内存映射、物理内存载入，子进程执行Hello程序，子进程结束后，shell父进程回收这个子进程，子进程映射到的内存中的状态信息和数据结构都被清除。

## 1.2 环境与工具

列出你为编写本论文，折腾Hello的整个过程中，使用的软硬件环境，以及开发与调试工具。

\1. 硬件环境

CPU：Intel Core i5

RAM：16GB

\2. 软件环境

Windows10 64位

VMware Workstation Pro

Ubuntu20.04

\3. 开发与调试工具

gcc、gdb、GNU readelf、cpp、ccl、as、ld

## 1.3 中间结果

列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。

| 文件名              | 作用                                 |
| ------------------- | ------------------------------------ |
| hello.i             | hello.c预处理后的文本文件            |
| hello.s             | hello.i编译后的汇编代码文件          |
| hello.o             | hello.s汇编后的可重定位目标文件      |
| hello               | hello.o链接后的可执行文件            |
| hello_o_elf.txt     | hello.o经readelf分析得到的文本文件   |
| hello_o_objdump.txt | hello.o经objdump反汇编得到的文本文件 |
| hello_elf.txt       | hello经readelf分析得到的文本文件     |
| hello_objdump.txt   | hello经objdump反汇编得到的文本文件   |

 

## 1.4 本章小结

本章以Hello程序为例简单解释了P2P、020的概念，说明了使用的环境及工具的相关信息，最后列出了所有中间文件和作用。

 

 

***\*（第1章0.5分）\****

 

 

# ***\* \*******\*第2章\**** ***\*预处理\****

## 2.1 预处理的概念与作用

1.预处理的概念

预处理是在编译前进行的处理，预处理器会扫描源代码，检查包含预处理指令的语句和宏定义并进行相应的替换，还会删除程序中的注释和多余的空白字符等，最终产生调整后的源代码提供给编译器。

 

2.预处理的作用

（1）文件包含：预处理程序把C程序中用“#include”格式中包含的文件的全部内容替换该行“#include”。包含文件的格式有#include后面跟尖括号< >和双引号” ”之分。

尖括号形式：用于包含系统提供的头文件，预处理器直接到系统目录中搜索尖括号中包含的文件，没搜索到就报错。双引号形式：用于包含自定义的头文件，首先到当前工作目录下查找该文件，若没找到再到系统目录中查找。

（2）宏定义：包含定义宏#define和宏删除#undef。预处理程序用define定义的实际值替换程序中#define定义的字符串。

（3）条件编译：有选择地执行相应操作，防止宏替换内容的重复包含，包括#if、#elif、#else、#endif、#ifdef、#ifndef。

（4）删除所有的注释，添加行号和文件名标识，以便编译时编译器产生调试用的行号信息保留所有#pragma编译指令。

 

 

## 2.2在Ubuntu下预处理的命令

***\*- $gcc -E hello.c -o hello.i\****

***\*- $cpp hello.c -o hello.i\****

***\*我们要求使用 -$ gcc -m64 -no-pie -fno-PIC -E hello.c -o hello.i\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps117.jpg)									图2.1 预处理命令

 

## 2.3 Hello的预处理结果解析

对hello.c进行预处理得到的hello.i共3055行，删除了#include和宏定义。首先是源代码文件等相关的一些信息（第 1 ~ 4 行）：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps118.jpg) 

图 2.2 源代码文件信息 

 

随后是预处理扩展的内容（第5 ~ 3041行），stdio.h、unistd.h、stdlib.h头文件被插入到文本文件中，所有的宏定义被替换，因此hello.i中没有#define和#include。 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps119.jpg) 

图 2.3 文件包含信息 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps120.jpg) 

图 2.4类型定义信息

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps121.jpg) 

图 2.5 函数声明

以stdio.h为例说明预处理的具体过程：stdio.h是系统标准库文件，cpp到Linux系统目录中查找 stdio.h，打开文件/usr/include/stdio.h，发现其中使用了“#define”、“#include” 等，cpp会对它们进行递归展开替换，最终的hello.i文件中删除了#include<stdio.h> 对于其中使用的“#ifdef”、“#ifndef”等条件编译语句，cpp会对条件值进行判断来决定是否对此部分进行包含。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps122.jpg) 

图 2.6 头文件路径位置

上图为hello.c包含的头文件在系统中的路径位置，cpp从这里读取、复制和处 

理这些头文件，将它们添加至hello.i。 

最后的部分是hello.c中的源代码（第3042 ~ 3055行），除注释“#define”和“#include” 语句被删除，内容基本不变。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps123.jpg) 

图 2.7 保留的源代码

 

## 2.4 本章小结

本章讨论了预处理的概念、作用和命令，分析了 hello.c 源代码文件的预 

处理过程，并对结果进行了相应的解析。

此过程深化了我对 C 语言预处理的理解。C 语言预处理由预处理器（C Pre-Processor）进行，主要完成四项工作：宏展开、文件包含复制、条件编译处理和 删除注释及多余空白字符，为之后的编译等流程奠定了基础。 

 

 

***\*（第2章0.5分）\****

# ***\* \*******\*第3章\**** ***\*编译\****

## 3.1 编译的概念与作用

***\*1.\**** ***\*编译的概念\**** 

编译是指对预处理后的源程序代码进行分析检查，确认所有语句均符合语法规则后将其翻译成汇编代码(assembly code)的过程。在此处指编译器将 hello.i 翻译成 hello.s。

***\*2.\**** ***\*编译的作用\**** 

(1) 词法分析：对由字符组成的单词进行处理，从左向右逐个字符地对源程序 进行扫描，产生单词符号，把作为字符串的源程序改造成为单词符号串的中间程序。 

(2) 语法分析：编译程序的语法分析器以单词符号作为输入，分析单词符号串 

是否形成符合语法规则的语法单位，如表达式、赋值、循环等，最后看是否构成一个符合要求的程序。 

(3) 代码优化：对程序进行多种等价变换，便于生成更有效的目标代码。 

(4) 目标代码：目标代码生成器把语法分析后或优化后的中间代码变换成目标 

代码，此处指目标代码为汇编代码。 

编译的作用是通过一系列步骤使得源代码更接近机器语言。编译是汇编阶段翻译成机器语言的前提。     

## 3.2 在Ubuntu下编译的命令

-$ gcc  -S hello.c -o hello.s

-$ gcc -S hello.i -o hello.s

我们的要求是 ***\*-$ gcc -m64 -no-pie -fno-PIC -S hello.i -o hello.s\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps124.jpg) 

图3.1 编译指令

## 3.3 Hello的编译结果解析

***\*3.3.1 hello.s文件的关键词\****

 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps125.jpg) 

图3.2 hello.s部分内容

.file 源文件是hello.c

.text 开始代码段

.section .rodata 下面是rodata节

.align 表示对指令和数据存放的地址8字节对齐

.size 声明大小

.long .string声明long、string类型

.LC0 .LC1声明了两个字符串

.global 声明全局变量main

.type 指定是函数类型或对象类型 hello.s 中有main, @function

### 3.3.2 数据类型

(1) 字符串

printf函数的参数字符串，保存在.rodata段，只读格式，汉字被存储为UTF-8格式，一个汉字用三个字节来表示。

第9行：printf("用法: Hello 学号 姓名 秒数!\n");

第13行：printf("Hello %s %s\n",argv[1],argv[2]);

对应的汇编代码（第5-8行）：

.section .rodata

.LC0:

.string	"\347\224\250\346\263\225: Hello \345\255\246\345\217\267 \345\247\223\345\220\215 \347\247\222\346\225\260\357\274\201"

.LC1:

.string     "Hello %s %s\n"

 

(2) 变量

a) 整数

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps126.jpg) 

int argc:作为main的第一个参数，等于main第二个参数argv数组的元素个数,汇编代码中存储在栈中的-20(%rbp).

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps127.jpg) 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps128.jpg) 

int i：编译器将局部变量i存在栈中-4(%rbp)，使用一条movl指令进行赋值，使用一条addl指令进行加一。

（3）立即数 ,如$0 $24

（4）数组： 

C代码中 char* argv[]是main函数的第二个参数，是一个char*类型的指针数组，每个元素占8字节，起始地址为argv，其中argv[0]为输入程序的路径和名称字符串,argv[1]、argv[2]作为printf的两个参数。在汇编代码中.LFB6代码块中（第23行）：movq  %rsi, -32(%rbp)。这条指令将main函数的第二个参数从寄存器写到了栈空间中。

 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps129.jpg) 

argv（指针数组的起始地址）存在-32(%rbp)位置的栈中，第34行把该值保存到%rax中，然后addq $16,%rax  将%rax的值加16，movq把此时的rax中保存的地址在内存中对应的值（argv[2]）保存到%rdx中，将argv[1]保存到%rsi中的操作与上述操作相同。

### 3.3.3 赋值操作

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps130.jpg)

图3.3指令后缀含义

数据长度不同，对应的指令不同。为局部变量i赋初值0的汇编语句

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps131.jpg) 

因为i是int类型的变量（4字节），所以用的是movl指令传送4字节

 

### 3.3.4 程序中的类型转换

从int转换为float时，不会溢出，但有可能数据被舍入；从int或 float转换为double时，由于double的有效位数更多，故能保留精确值； 从double转换为float和int时，可能发生溢出，由于有效位数变少，故可能被舍入； 从float 或double转换为int时，因为int没有小数部分，所以数据可能会向0方向被截断。

hello程序中没有隐式强制类型转换。对应的汇编代码中也不存在该操作。

 

### 3.3.5 算术操作

在for循环体，对循环变量i的更新使用了自增运算，源程序代码是for(i=0;i<8;i++) 。对应汇编代码如下，addl $1 ，-4(%rbp) 把地址为%rbp-4对应的内存中的值加一。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps132.jpg) 

在读取argv[2]时对argv的地址加16使用了addq（q传送8字节），汇编代码把%rax寄存器中的值加16。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps133.jpg) 

此外还有初始将%rsp的值减32使得栈下移变大。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps134.jpg) 

### 3.3.6 关系操作及控制转移

(1) 程序中if条件判断处的关系操作与控制转移：

源程序代码

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps135.jpg) 

对应的汇编代码为

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps136.jpg) 

je使用cmpl设置的条件码(ZF)，若ZF = 0，说明argc等于4，控制转移至.L2（for循环部分）；若ZF = 1，说明argc不等于4（即执行程序时传入的参数个数不符合要求），继续执行输出提示信息并退出。

 

(2) 程序中for循环终止条件判断涉及的关系操作与控制转移：

源程序代码

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps137.jpg) 

汇编代码为

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps138.jpg) 

此处jle使用cmpl设置的条件码(ZF SF OF)，若(SF^OF) | ZF = 1，说明循环终止条件不成立（变量i的值小于或等于7），控制转移至.L4，继续执行循环体；若(SF^OF) | ZF = 0，则循环终止条件成立（变量i的值达到8），不再跳转至循环体开始位置，继续向后执行直至退出。源程序代码与编译器生成的有细微的差别.源代码中判断i<8，而编译器将其调整为判断i<=7。

### 3.3.7 函数操作

源代码中的函数有main，printf，atoi，exit，sleep，getchar。

(1) main函数：

a) 参数：int argc, char *argv[]

相关汇编代码：

.LFB6代码块中：

  ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps139.jpg)

由此可见，第一个参数通过寄存器%rdi传递，第二个参数通过寄存器%rsi传递，将两个参数写入栈中。

b) 函数调用：被系统启动函数_libc_start_main调用，hello.s中没有体现，但为汇编器进行相关处理提供了信息。

汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps140.jpg) 

汇编指令标记了程序入口等信息，提供给汇编器必要的信息。

c) 函数返回：

正常情况return 0：

   ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps141.jpg)

leave指令把栈空间恢复到调用之前的状态，等同于mov %rbp %rsp pop %rbp

最后ret指令把PC设置为返回地址。

调用exit函数返回1退出：

   ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps142.jpg)

(2) printf函数：

a) 参数：需要输出的字符串和格式。

C源代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps143.jpg) 

汇编：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps144.jpg) 

printf只有一个字符串参数，汇编代码中被优化为调用puts函数，%rdi中存$.LC0字符串的首地址，作为调用puts函数的第一个参数。

 

C源代码：![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps145.jpg)

对应汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps146.jpg)注从栈空间出argc[1]、argc[2]存到%rsi 和%rdx中作为第二个和第三个参数，$.LC1字符串的起始地址存到%rdi中作为第一个参数，传递给printf。

b) 函数调用：主函数通过call指令调用。

c) 函数返回：返回值被忽略。

(3) exit函数：

a) 参数传递：退出状态值

源代码：

 ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps147.jpg)

汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps148.jpg)注：使用寄存器%edi存整型值1作为第一个参数，调用exit函数以状态1退出。

b) 函数调用：主函数通过call指令调用。

c) 函数返回：函数不返回，直接退出程序。 

(4) atoi函数：

a) 参数传递：运行可执行程序时输入的第四个字符串，要将它转成整形值作为sleep函数的参数

C代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps149.jpg) 

汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps150.jpg) 

把argv[3]存到寄存器%rdi中，作为atoi函数的参数

b）函数调用：主函数通过call指令调用

c）函数返回：atoi函数返回值存在寄存器%rax中，用作后序传递给寄存器%rdi调用sleep函数。

 

(5) sleep函数：

a)参数传递：将atoi函数的返回值（%eax中）传给寄存器%rdi中作为sleep函数的第一个参数。

源代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps151.jpg) 

汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps152.jpg) 

b) 函数调用：主函数通过call指令调用。

c) 函数返回：返回值（实际休眠时间）被忽略。

(6) getchar()函数：

a) 参数传递：无。

C代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps153.jpg) 

汇编代码：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps154.jpg) 

b) 函数调用：主函数通过call指令调用

c) 函数返回：返回char类型值，在此程序中被忽略。

### 3.3.7 最终结果

经过编译后，得到了汇编文件hello.s，仍然是可读的文本文件，无法被CPU理解和执行。

## 3.4 本章小结

本章围绕hello.i经编译器编译得到hello.s的过程，介绍了编译的概念和过程，围绕数据、赋值、类型转换、算术操作、逻辑/位操作、关系操作、数组/指针、关系操作及控制转移、函数调用的过程，分析了Hello程序的编译结果。编译阶段分析检查源程序，确认所有的语句都符合语法规则后将其翻译成等价的汇编代码（中间代码）表示。完成本章内容的过程加深了我对编译阶段的理解。

***\*（第3章2分）\****

# ***\* \*******\*第4章\**** ***\*汇编\****

## 4.1 汇编的概念与作用

**1.** ***\*汇编的概念\****

汇编器as将汇编语言程序（hello.s）翻译成机器语言指令，并将这些指令打包成可重定位目标文件的过程称为汇编，翻译结果hello.o是二进制编码文件，包含程序的机器指令编码。

**2.** ***\*汇编的作用\****

汇编过程将汇编程序转化为机器可直接识别的机器语言程序。

## 4.2 在Ubuntu下汇编的命令

–$ gcc –c hello.s –o hello.o

–$ gcc –c hello.c –o hello.o

–$ as  hello.s  -o hello.o

我们使用***\*gcc -m64 -no-pie -fno-PIC -c hello.s -o hello.o\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps155.jpg) 

图4.1 汇编指令

## 4.3 可重定位目标elf格式

分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是***\*重定位项目分析。\****

### 4.3.1 readelf命令

-$ ***\*r\*******\*eadelf -a hello.o > hello\*******\*_o\*******\*_elf.txt\****

将hello.o中ELF格式相关信息重定向至文件hello_o_elf.txt。

命令执行效果截图：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps156.jpg) 

​            图4.2  readelf指令

 

  

### 4.3.2 ELF头

ELF头位于ELF文件开始，包含文件结构说明信息，分为32位和64位版本

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps157.jpg) 

图 4.3 ELF头信息

Magic魔数用于标识ELF文件的类型和格式，45 4c 46分别对应ASCII码的ELF，操作系统在加载可执行文件时会确认是否正确。如果不正确则拒绝加载。

ELF头类型为ELF64，为小端序补码格式，版本号为1（current），操作系统平台是Unix -System 5，ABI版本是0，文件类型为可重定位目标文件。ELF头还定义了机器类型为advanced micro devices x86-64，程序执行的入口地址是0x0。

段头表的起始地址是0（bytes into file），节头目表的起始位置是1192（bytes into file），Flags是0x0，段头表数量和大小都是0，节头表的大小是64bytes，节头部表数量是14，字符串表在节头目表的索引是13。

### 4.3.3 节头目表

除ELF头外，节头目表是可重定位文件中最重要部分，此部分列出了hello.o中每个节的名称、类型、地址、偏移量、大小、对齐方式等信息。具体内容如下：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps158.jpg)  ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps159.jpg)

图 4.4 节头目表信息

***\*分析：\****

(1) .text节：已编译程序的机器代码；.rela.text：针对.text段的重定位表；.data：已初始化的全局和静态C变量；.bss：未初始化的全局和静态C变量；.rodata：只读数据；.symtab：存放程序中定义和引用的函数和全局变量信息；.symtab：存放程序中定义和引用的函数和全局变量信息；.strtab：字符串表，保存普通字符串，如符号的名字；.shstrtab：段表字符串表，保存段表中用到的字符串，如段名。

(2) 由于是可重定位目标文件，所以每个节地址都从0开始，用于重定位；

(3) 有4个节会分配存储空间：.rela.text 、.comment、.rela.eh_frame、.symtab

(4) Flags表明是否可读、写、执行。.text段是可执行的，但是不能写；.data段和.bss段可写，都不可执行；.rodata段可读不可写；

### 4.3.4 重定位节

重定位节记录了各段引用的符号相关信息，汇编器遇到引用时，生成一个重定位条目，数据引用的重定位条目在.rel_data节中，指令中引用的重定位条目在.rel_text节中。在链接时，需要通过重定位节对这些位置的地址进行重定位。链接器会通过重定位条目的类型判断如何计算地址值并使用偏移量等信息计算出正确的地址。

具体内容如下：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps160.jpg) 

图 4.5 重定位节信息

Offset：需要重定向的符号在节中的偏移位置；Info：包括 symbol 和 type 两部分，其中 symbol 占前 4 个字节，type 占后 4 个字节，symbol 代表重定位到的目标在.symtab中的偏移量，type 代表重定位的类型。Type：重定位到的目标的类型；Addend：计算重定位位置的辅助信息，共占 8 个字节；Name：重定向到的目标的名称。

本程序需要重定位的符号有：.rodata，puts，exit，printf，atoi，sleep，getchar及.text等。注意到重定位类型有R_X86_64_PC32（PC相对寻址）、R_X86_64_PLT32（使用PLT表寻址）、R_X86_64_32（绝对寻址）。

### 4.3.5 符号表

符号表（.symtab）存放在程序中定义和引用的函数和全局变量的信息，是一个结构数组，重定位需要引用的符号都在其中声明。

具体内容：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps161.jpg) 

图 4.6 符号表信息

Value：对应字符串在strtab节中的偏移量

Size：符号对应目标字节数

Type：符号类型，包括数据、函数、源文件、节、未知

Bind：绑定属性，包括全局符号、局部符号、弱符号

Ndx：对应目标所在的节，或其他情况，比如 UND节

Name：名字

 

## 4.4 Hello.o的结果解析

说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的***\*操作数\****与汇编语言不一致，特别是***\*分支转移函数调用\****等。

 

***\*命令：\*******\*-$\**** objdump -d -r hello.o > hello_o_objdump.txt

 

***\*反汇编代码：\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps162.jpg) 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps163.jpg) 

图4.7 hello.o的反汇编代码

***\*分析：\****

(1) 数的表示：hello.s中的操作数表示为十进制，而hello.o反汇编代码中的操作数被转换成十六进制；

(2) 指令命名:hello.o的反汇编文件中省略了很多指令结尾的’q’，却给call和ret指令加上了’q’后缀。

(3) 分支控制：hello.s中是跳转到的位置是.L2、.LC1，是代码块的名称，而反汇编代码中跳转指令跳转的位置是相对于main函数起始位置偏移的地址（相对地址）如jle 36<main+0x36>；

(4) 函数调用：hello.s中，call指令使用的是函数名，而反汇编代码中call指令后的相对地址设置为***\*0\****，只有在链接之后才能确定运行时的实际地址，比如

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps164.jpg) 

(5) hello.s中的全局变量、printf字符串等符号在反汇编代码中地址在运行时确定，访问需要重定位，在汇编成为机器语言时，会将操作数设置为全 0 并在rel.data节添加重定位条目。

(6) hello.s中提供给汇编器的辅助信息在反汇编代码中不再出现，如“.cfi_endproc”，“	.cfi_def_cfa 7, 8”等。

 

## 4.5 本章小结

本章对汇编的概念、作用、可重定向目标文件的结构及反汇编代码等进行了较为详细介绍,分析了汇编对文本.s文件的相应处理，查看 hello.o 的 elf 格式并详细分析ELF头，重定位信息和节头部表的各部分详细含义，并对 objdump 得到的反汇编代码与 hello.s 进行比较。通过汇编器，汇编语言代码(hello.s)转化为机器语言，生成的可重定位目标文件(hello.o)为随后的链接阶段做好了准备。完成本章内容的过程加深了我对汇编过程、ELF格式以及重定位的理解。

 

 

***\*（第4章1分）\****

 

 

# ***\* \*******\*第\*******\*5\*******\*章\**** ***\*链接\****

## 5.1 链接的概念与作用

**1.** ***\*链接的概念\****

链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。链接可以执行于编译时，也就是在源代码被编译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；也可执行于运行时，也就是由应用程序来执行。在现代系统中，链接是由叫做链接器的程序自动执行的。

**2.** ***\*链接的作用\****

链接使分离编译成为可能，我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解成更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。

在此处，链接是指将可重定向目标文件hello.o与其他一些文件组合成为可执行目标文件hello。

## 5.2 在Ubuntu下链接的命令

ld  -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o -o hello

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps165.jpg) 

图5.1 链接指令

## 5.3 可执行目标文件hello的格式

 分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。

使用命令：readelf -a hello > hello_elf.txt将hello中ELF格式相关信息重定向至文件hello_elf.txt。

5.3.1 ELF文件头：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps166.jpg) 

图5.2ELF头

Magic：ELF头的魔数，用于标识ELF文件的类型和格式，45 4c 46分别对应ASCII码的ELF，操作系统在加载可执行文件时会确认是否正确。如果不正确则拒绝加载。

ELF头类型为ELF64，为小端序补码格式，版本号为1（current），操作系统平台是Unix -System 5，ABI版本是0。

文件类型为可执行文件。ELF头还定义了机器类型为advanced micro devices x86-64，程序执行的入口地址是0x4010f0，不再是hello.o ELF格式中的0。

段头表的起始地址是64（bytes into file），节头目表的起始位置是14208（bytes into file），Flags是0x0，头大小是64bytes，段头表大小是56bytes，段头表数目是12，节头目表的大小是64bytes，节头部表数量是27，字符串表在节头目表的索引是13。

 

5.3.2 节头目表：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps167.jpg) 

​        

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps168.jpg) 

​         图5.3节头目表

描述了各个节的大小、偏移量和其他属性。链接器链接时，会将各个文件的相同段合并成一个大段，并且根据这个大段的大小以及偏移量重新设置各个符号的地址。

 

 

5.3.3 dynamic section（动态节）：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps169.jpg) 

​              图5.4 dynamic  section

 

5.3.4 符号表：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps170.jpg) 

​     图5.5符号表

用来存放程序中定义和引用的函数和全局变量的信息。新的符号表多了很多符号

Value：对应字符串在strtab节中的偏移量；Size：对应目标字节数；Type：包括数据、函数、源文件、节、未知类型；Bind绑定属性：全局符号、局部符号、弱符号；Ndx符号对应目标所在的节，或其他情况，比如 UND节；Name：名字

 

5.3.3可执行文件中的段头表

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps171.jpg) 

​          图5.6段头目表

程序头表描述可执行文件中的节与虚拟空间中的存储段之间的映射关系。一个表项说明虚拟地址空间中一个连续的段或一个特殊的节。程序头表信息有若干个表项，其中若干个为可装入段。

一个可装入段是包括ELF头、程序头表、.init、.text和.rodata节，映射到虚拟地址的一个区域，按一定大小对齐，具有只读/执行权限，是只读代码段。另一个可装入段：.data.bss节，映射到虚拟地址，映射到虚拟地址的一个区域，按一定大小对齐，前部分.data节内容初始化, 后面对应.bss节, 初始化为0，具有可读可写权限，是可读写数据段。

5.3.4其余部分

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps172.jpg) 

​       图5.7其余部分

 

 

## 5.4 hello的虚拟地址空间

使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。 

使用edb加载hello：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps173.jpg) 

 图5.8edb加载hello

此时Data Dump窗口中显示的就是hello的虚拟空间内容，如下图，显示范围为0x401000至0x402000。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps174.jpg) 

图 5.9 Data Dump窗口

程序包含PHDR，INTERP，LOAD，DYNAMIC，NOTE，GNU_STACK，GNU_RELRO几个部分，其中PHDR 保存程序头表。INTERP 指定在程序已经从可执行文件映射到内存之后，必须调用的解释器。LOAD 表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据、程序的目标代码等。DYNAMIC 保存了由动态链接器使用的信息。NOTE 保存辅助信息。GNU_STACK：权限标志，用于标志栈是否是可执行。GNU_RELRO：指定在重定位结束之后哪些内存区域是需要设置只读。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps175.jpg)

图5.10 进程视图

与5.3对照：通过与Symbols窗口对照，可以发现各段均一一对应，如下图

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps176.jpg) 

图 5.11 Symbols与Data Dump对照截图1

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps177.jpg) 

图 5.12 Symbols与Data Dump对照截图2

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps178.jpg) 

图 5.13 Symbols与Data Dump对照截图3

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps179.jpg) 

图 5.14 Symbols与Data Dump对照截图4（.text段部分）

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps180.jpg) 

图 5.15 Symbols与Data Dump对照截图5（.rodata段部分）

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps181.jpg)![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps182.jpg) 

 图5.16 节头目标

## 5.5 链接的重定位过程分析

***\*命令：\*******\*-$\**** ***\*o\*******\*bjdump -d -r hello > hello_\*******\*objdump\*******\*.txt\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps183.jpg) 

  图5.17 hello的反汇编指令

 

5.51新增节 hello增加了.init 和.plt节和一些节中定义的函数

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps184.jpg)![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps185.jpg) 

图 5.18  hello的.init节和.plt节

 

5.52  hello中加入了一些函数，如_start()以及一些主函数中调用的库函数，如下图所示：

​     ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps186.jpg)

​     ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps187.jpg)

​        图 5.19  hello增加的一些函数

5.5.3 函数调用地址：

hello实现了调用函数时的重定位，因此在调用函数时调用的地址已经是函数确切的虚拟地址。

​     ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps188.jpg)

​       图5.20 函数调用

链接器解析重定位条目时时发现对外部函数调用的类型是R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text和.plt节相对位置已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下一条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。

5.5.4控制流跳转地址：

hello实现了调用函数时的重定位，因此在跳转时调用的地址已经是函数确切的虚拟地址。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps189.jpg) 

5.5.5 重定位过程：

链接就是链接器（ld）将各个目标文件（各种.o文件）组装在一起，文件中的各个函数段按照一定规则累积在一起。从.o提供的重定位条目将函数调用和控制流跳转的地址填写为最终的地址。hello中不再存在hello.o中的重定位条目，并且跳转和函数调用的地址在hello中都变成了虚拟内存地址。

链接过程会扫描分析所有相关的可重定位目标文件，并完成两个主要任务：首先进行符号解析，将每个符号引用与一个符号定义关联起来。

进行重定位，链接器使用汇编器产生的重定位条目的详细指令，把每个符号定义与一个内存位置关联起来。最终的结果是将程序运行所需的各部分组装在一起，形成一个可执行目标文件。

链接器在完成符号解析以后，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。然后就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时的地址。重定位由两部组成。在hello到hello.o中，首先是重定位节和符号定义，链接器将所有输入到hello中相同类型的节合并为同一类型的新的聚合节。例如，来自所有的输入模块的.data节被全部合并成一个节，这个节成为hello的.data节。

然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每一个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。然后是重定位节中的符号引用，链接器会修改hello中的代码节和数据节中对每一个符号的引用，使得他们指向正确的运行地址。

\1. PC相对寻址：refaddr = ADDR(s) + r.offset

\2. 

  ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps190.jpg)

链接器解析重定位条目时时发现对外部函数调用的类型是R_X86_64_PLT32的重定位，此时动态链接库中的函数已经加入到了PLT中，.text和.plt节相对位置已经确定，链接器计算相对距离，将对动态链接库中函数的调用值改为PLT中相应函数与下一条指令的相对地址，指向对应函数。对于此类重定位链接器为其构造.plt与.got.plt。

hello.o反汇编代码的exit、printf、sleep、getchar都是相对引用。在符号表中,这几个符号条目的地址都是0，因为它们是动态链接的，与当前模块无关，不在符号表中，这些函数的引用都在PLT中 ，故我们要通过PLT算出这些符号的地址。

 

2.绝对寻址：R_X86_64_32

  ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps191.jpg)

  ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps192.jpg)

重定位符号是 rodata的用的是绝对引用。

## 5.6 hello的执行流程

在EDB执行hello前添加程序参数（相当于在终端中输入./hello 120L021520 臧德阳 1）：

***\*加载程序\****：

ld-2.27.so!_dl_start

ld-2.27.so!_dl_init

hello!_start

libc-2.27.so!_libc_start_main

libc-2.27.so!_cxa_atexit 

libc-2.27.so!_libc_csu_init

hello!_init

libc-2.27.so!_setjmp

libc-2.27.so!_sigsetjmp

libc-2.27.so!_sigjmp_save

***\*程序运行：\****

hello!main 

hello!puts@plt

hello!exit@plt

hello!printf@plt

hello!atoi@plt

hello!sleep@plt

hello!getchar@plt

ld-2.27.so!_dl_runtime_resolve_xsave

ld-2.27.so!_dl_fixup

ld-2.27.so!_dl_lookup_symbol_x

***\*程序结束：\****

libc-2.27.so!exit

 

 

## 5.7 Hello的动态链接分析

.glt.pot :0x404000 

下图为调用dl_init之前.got.plt段的内容：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps193.jpg) 

图5.21

下图为调用dl_init之后.got.plt段的内容：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps194.jpg) 

图5.22

可以很明显地看出第2、3行的变化。

对于动态共享链接库中PIC函数，编译器没有办法预测函数的运行时地址，所以需要添加重定位记录，等待动态链接器处理，为避免运行时修改调用模块的代码段，链接器采用延迟绑定的策略。延迟绑定通过全局偏移量表(GOT)和过程链接表(PLT)的协同工作实现函数的动态链接，其中GOT中存放函数目标地址，PLT使用GOT中地址跳转到目标函数。

在此之后，程序调用共享库函数时，会首先跳转到PLT执行指令，第一次跳转时，GOT条目为PLT下一条指令，将函数ID压栈，然后跳转到PLT[0]，在PLT[0]再将重定位表地址压栈，然后转进动态链接器，在动态链接器中使用两个栈条目确定函数运行时地址，重写GOT，再将控制传递给目标函数。以后如果再次调用同一函数，则通过间接跳转将控制直接转移至目标函数。

 

## 5.8 本章小结

本章围绕可重定位目标文件hello.o链接生成可执行目标文件hello的过程，介绍了链接的概念和作用，分析了链接对文本hello.o文件的相应处理，查看 hello 的 elf 格式并分析，详细地分析ELF头，重定位信息和段头部表的各部分含义，并对 objdump得到的反汇编代码与hello.s进行比较，了解链接时重定位等操作对于相关信息的转换，并对结果进行了相应的解析。

在此过程中，我更加深刻地理解了链接和重定位的相关概念，复习了课程第7章的相关知识，了解了动态链接的过程及作用。

 

***\*（第5章1分）\****

# ***\* \*******\*第\*******\*6\*******\*章\**** ***\*hello进程管理\****

## 6.1 进程的概念与作用

**1.** ***\*进程的概念\****

进程是一个执行中的程序的实例，每一个进程都有它自己的地址空间，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储区着活动过程调用的指令和本地变量。

**2.** ***\*进程的作用\****

进程提供给应用程序的关键抽象：一个独立的逻辑控制流，如同程序独占地使用处理器；一个私有的地址空间，如同程序独占地使用内存系统。

 

## 6.2 简述壳Shell-bash的作用与处理流程

***\*作用\****：Shell-bash是一个交互型应用级程序，代表用户运行其他程序。它是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。

***\*处理流程\****：shell从终端读取输入的命令，将字符串切分获得参数，然后检查是否是内部命令，若是就立即执行，将被分解为系统调用并传给Linux内核；否则在路径里找到是否有这个可执行文件，如果有就调用相应的程序为其分配子进程并运行。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。。

简化处理流程：

(1) 从终端读入输入的命令；

(2) 将输入字符串切分获得所有的参数；

(3) 如果是内置命令则立即执行；

(4) 若不是则调用相应的程序执行；

(5) shell应该随时接受键盘输入信号，并对这些信号进行相应处理。

## 6.3 Hello的fork进程创建过程

根据shell的处理流程，键入命令（./hello 120L021520 臧德阳 1）后，shell判断hello不是内部指令而是一个可执行文件，调用fork函数创建子进程。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。子进程会得到一份与父进程用户级虚拟空间相同且独立的副本——包括数据段、代码、共享库、堆和用户栈等，父进程打开的文件，子进程也可读写。二者之间最大的不同在于PID的不同。fork函数被调用一次会返回两次，在父进程中，fork函数返回子进程的PID，在子进程中，fork函数返回0。在子进程执行期间，父进程默认选项是显式地等待子进程的完成。新创建的子进程几乎完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（ 但是独立的）一份副本，这就意味着，当父进程调用fork 时，子进程可以读写父进程中打开的任何文件。

流程示意：

新的子进程hello

​     +------------->+

​     |        |

​     |        |

shell---->+------------>+--------->

​     fork      waitpid

 

## 6.4 Hello的execve过程

execve函数原型： int execve(const char* filename,const char* argv[],const char* envp[]);

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps195.jpg) 

图6.1 参数列表与环境变量

execve函数在当前进程的上下文加载并运行可执行目标文件*filename（hello），且带参数列表argv和环境变量列表envp。只有出现错误,如不到可执行目标文件hello，execve才会返回到调用程序。所以，与fork一次调用返回两次不同，execve 调用一次从不返回。

argv变量指向一个以NULL结尾的指针数组，其中每个指针都指向一个参数字符串。argv[0]是可执行目标文件的名字。环境变量列表也由一个类似的数据结构表示，envp指向一个以NULL结尾的指针数组，其中每个指针指向一个环境变量字符串，每个字符串都是形如”name=value”的“名字-值”对。

execve函数在加载了hello之后，它调用启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数原型如下：

int main(int argc, char **argv, char *envp)

execve函数的执行过程会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开的所有文件描述符。

exceve过程会删除已存在的用户区域，为Hello的代码、数据、.bss和栈区域创建新的区域结构，所有这些区域都是私有的、写时才复制的；并且映射共享区：Hello程序与标准C库libc.so链接，这些对象都是动态链接到Hello的，在用户虚拟地址空间中的共享区域内；设置PC，使之指向代码区域的入口点。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps196.jpg) 

​        图6.2 用户栈结构

## 6.5 Hello的进程执行

结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。

***\*上下文\****：内核重新启动一个被抢占的进程所需要恢复的原来的状态，由寄存器、程序计数器、用户栈、内核栈和内核数据结构等对象的值构成。

***\*逻辑控制流：\****一系列程序计数器 PC 的值的序列叫做逻辑控制流，进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占而暂时挂起，然后轮换到其他进程。

***\*进程上下文切换：\****在内核调度了一个新的进程运行时，它就抢占当前进程，并使用一种上下文切换的机制来控制转移到新的进程。具体过程为：①保存当前进程的上下文；②恢复某个先前被抢占的进程被保存的上下文；③将控制传递给这个新恢复的进程。

***\*时间片\****：一个进程执行它的控制流的一部分的每一个时间段叫做时间片(time slice)，多任务也叫时间分片(time slicing)。

***\*进程调度：\****在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程，这种决策称为调度，是由内核中的调度器代码处理的。当内核选择一个新的进程运行，我们说内核调度了这个进程。在内核调度了一个新的进程运行了之后，它就抢占了当前进程，并使用上下文切换机制来将控制转移到新的进程。

hello程序调用sleep函数时，内核将通过进程调度进行上下文切换，将控制转移到其他进程。当hello程序休眠结束后，进程调度使hello程序重新抢占内核，继续执行。hello 初始运行在用户模式，在 hello 进程调用 sleep 之后陷入内核模式，内核处理休眠请求主动释放当前进程，并将 hello 进程从运行队列中移出加入等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他进程，当定时器到时发送一个中断信号，此时进入内核状态执行中断处理，将 hello 进程从等待队列中移出重新加入到运行队列，成为就绪状态，hello进程就可以继续运行自己的控制逻辑流。

***\*h\*******\*ello\*******\*程序进程执行示意图：\****

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps197.png) 

图6.3上下文切换

***\*用户态与核心态的转换：\****

为了保证系统安全，需要限制应用程序所能访问的地址空间范围，因而存在用户态与核心态的划分。处理器使用一个寄存器作为模式位来描述当前进程的特权。用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。进程只有故障、中断或陷入系统调用时才会得到内核访问权限，其他情况下始终处于用户权限之中，一定程度上保证了系统的安全性。

## 6.6 hello的异常与信号处理

异常就是控制流中的突变,用来响应处理器状态中的某些变化。状态变化被称 为事件,事件可能与当前指令的执行直接相关，如发生虚拟内存缺页、算术溢出,或者试图除零；另一方面,事件也可能和当前指令的执行没有关系，如一个系统定时器产生的信号或者一个I/O请求完成。 当处理器检测到异常,会通过异常跳转表,调用异常处理程序。当异常处理程序完成处理后,根据引起异常的事件的类型来决定是否返回或返回到哪一条指令。                             hello执行过程中可能出现四类异常：中断、陷阱、故障和终止。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps198.jpg) 

图6.4 x86-64系统的异常示例

中断是来自I/O设备的信号，异步发生，中断处理程序对其进行处理，返回后继续执行调用前待执行的下一条代码，就像没有发生过中断。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps199.jpg) 

图6.5中断处理

陷阱是有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。					![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps200.jpg)

​           图6.6 陷阱处理

故障是由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps201.jpg) 

图6.7故障处理

终止是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程序会将控制返回给一个abort例程，该例程会终止这个应用程序。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps202.jpg) 

图6.8终止处理

***\*h\*******\*ello\*******\*执行过程中的信号及处理：\****

l SIGINT：键入Ctrl-C后内核向hello进程发送，终止程序。

l SIGSTP：键入Ctrl-Z后内核向hello进程发送，停止直到下一个SIGCONT。

l SIGCONT：键入fg后内核向hello进程发送，若停止则继续执行。

l SIGKILL：键入kill -9 <PID>后内核向hello进程发送，终止程序。

 

 ***\*执行截图：\****

中途乱按：只是将屏幕的输入缓存到缓冲区。乱码被认为是命令![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps203.jpg)

图6.9 中途乱按

按下 ctrl-c ，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收 hello进程。

程序终止:

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps204.jpg) 

  图6.10 ctrl c终止进程

 

 

键入ctrl-z后，shell 父进程收到一个SIGSTP信号，信号处理函数的默认逻辑是打印屏幕回显，将hello进程挂起。

通过 ps 命令我们可以看出 hello 进程没有被回收，调用fg命令将其调到前台，此时 shell 程序首先打印 hello 的命令行命令，hello 继续运行打印。之后输入字串，程序结束，同时进程被回收。

 

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps205.jpg) 

​     ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps206.jpg)

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps207.jpg) 

图6.11 ctrl-z和fg命令

用kill命令杀死hello进程：挂起的进程被终止，在ps中无法查到到其PID。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps208.jpg) 

图6.12  kill命令

终止hello进程前pstree结果：

   ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps209.jpg)

​       图6.13 终止hello进程前pstree部分

终止hello进程后pstree结果：

 ![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps210.jpg)

​     图6.14终止hello进程后pstree部分

 

 

## 6.7本章小结

本章主要阐述了hello的进程管理，包括进程创建、加载、执行以至终止的全过程，并分析了执行过程中的异常、信号及其处理，介绍了进程的概念与作用、 Shell及其工作流程，展示了fork函数如何创建新进程。之后展示了 execve加载hello程序的过程，以及 hello进程的执行过程，介绍进程时间片的概念、进程调度的过程、用户态与核心态的转换等。

在hello程序运行的过程中，内核对其进行进程管理，决定何时进行进程调度，在接收到不同的异常、信号时，还要及时地进行对应的处理。本章的内容引导我复习了课程中的异常控制流相关内容，使我对进程、信号及异常相关概念的理解更加深刻。

 

***\*（第6章1分）\****

# ***\* \*******\*第\*******\*7\*******\*章\**** ***\*hello的存储管理\****

## 7.1 hello的存储器地址空间

结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念。

**1.** ***\*逻辑地址\****

逻辑地址是指由程序产生的与段相关的偏移地址部分，是相对应用程序而言的，如hello.o中代码与数据的相对偏移地址。逻辑地址的格式在实模式下为“段地址：偏移地址”，在保护模式下为“段选择符：偏移量”，经过段式映射到线性地址。

**2.** ***\*线性地址\****

线性地址是指一个非负整数地址的有序集合，是逻辑地址到物理地址变换之间的中间层。程序hello的代码会产生段中的偏移地址，加上相应段的基地址就生成了一个线性地址。

**3.** ***\*虚拟地址\*******\*：\****

程序使用的地址，CPU通过生成一个虚拟地址来访问主存，这个 虚拟地址被送到内存之前通过硬件与操作系统被转换成适当的物理地址。

**4.** ***\*物理地址\****

物理地址是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址（hello程序运行时代码、数据等对应的可用于直接在内存中寻址的地址）。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址；如果没有启用分页机制，那么线性地址就直接成为物理地址了。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps211.jpg)

图7.1 实模式和保护模式下寻址

## 7.2 Intel逻辑地址到线性地址的变换-段式管理

段式管理就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存单元。段是虚拟地址到线性地址转化的基础。每个段有三个参数定义。段基地址：指定段在线性地址空间中的开始地址。基地址是线性地址对应于段中偏移0处。段限长：是虚拟地址空间中段内最大可用偏移地址。定义了段的长度。段属性：指定段的特性。如该段是否可读、可写或可作为一个程序执行，段的特权级等。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps212.png)

​        图7.2 段描述符

这三个参数存储在一个称为段描述符的结构项中。在逻辑地址到线性地址的转换映射过程中会使用这个段描述符。段描述符保存在内存中的段描述符表中。

当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS（代码段寄存器），DS（数据段寄存器），SS（堆栈段寄存器）来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS所指的64K内，这就是COM文件不得大于64K的原因。

段寄存器是因为对内存的分段管理而设置的。计算机需要对内存分段，以分配给不同的程序使用（类似于硬盘分页）。在描述内存分段时，需要有如下段的信息：1.段的大小；2.段的起始地址；3.段的管理属性（禁止写入/禁止执行/系统专用等）。

处理器把逻辑地址转化成一个线性地址的过程：

\1. 首先确定要访问的段，然后决定使用的段寄存器。

\2. 使用段选择符中的索引值在GDT或LDT中定位相应的段描述符,他们的首地址则通过GDTR寄存器和LDTR寄存器来获得  

\3. 将段选择符的索引值*8,然后加上GDT或LDT的首地址,就能得到当前段描述符的地址。

\4. 利用段描述符校验段的访问权限和范围,以确保该段是可以访问的并且偏移量位于段界限内。

\5. 利用段描述符中取得的段基地址加上偏移量,形成一个线性地址。

## 7.3 Hello的线性地址到物理地址的变换-页式管理

页式管理将各进程的虚拟空间划分成若干个长度相等的页(page)，把内存空间按页的大小划分成片或者页面（page frame），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机制，来解决离散地址变换问题。页式管理采用请求调页或预调页技术实现了内外存存储器的统一管理。

n位（Core i7为48位）的线性地址包含两部分：一个p位的虚拟页面偏移（VPO）和一个(n-p)位的虚拟页号。MMU利用虚拟页号（VPN）来选择适当的PTE（页表项），若PTE有效位为1，则说明其后内容为物理页号（PPN），否则缺页。而物理地址中低p位的物理页偏移量（PPO）与虚拟页偏移量（VPO）相同，PPN与PPO连接即得物理地址。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps213.jpg) 

​      图7.3 虚拟地址翻译成物理地址

hello进程执行时，CPU中的页表基址寄存器指向hello进程的页表，当hello进程访问其虚拟空间内的指令、数据等内容时，CPU芯片上的MMU（内存管理单元）会将对应的线性地址变换为物理地址以进行寻址访问。页表将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换为物理地址时,都会读取页表。操作系统负责维护页表的内容,以及在磁盘与物理内存之间来回传送页。

分页机制是对虚拟地址内存空间进行分页， Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为 hello 进程维护一个段的任务结构即图中的 task_struct，其中条目 mm 指向一个 mm_struct，它描述了虚拟内存的当前状态，pgd 指向第一级页表的基地址（结合一个进程一串页表），mmap 指向一个 vm_area_struct 的链表，一个链表条目对应一个段，所以链表相连指出了 hello 进程虚拟内存中的所有段。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps214.jpg) 

图7.4 页表

## 7.4 TLB与四级页表支持下的VA到PA的变换

***\*TLB\*******\*（\*******\*翻译后备缓冲器\*******\*）\*******\*：\****每次CPU产生一个虚拟地址，MMU就必须查阅一个PTE（页表条目），以便将虚拟地址翻译为物理地址，会从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就会下降到1或2个周期。系统在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓存器（TLB）。

***\*多级页表：\****多级页表为层次结构，用于压缩页表。这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在；第二，只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、页面调出或调入二级页表，最经常使用的二级页表才缓存在主存中，减少了主存的压力。

***\*VA到PA的变换：\****对于四级页表，虚拟地址（VA）被划分为4个VPN和1个VPO。每个VPN i都是一个到第i级页表的索引。对于前3级页表，每级页表中的每个PTE都指向下一级某个页表的基址，最后一级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。PPO和VPO是相同的。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps215.jpg) 

图7.5 用页表翻译虚拟地址

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps216.jpg) 

图7.6TLB和四级页表支持下的VA到PA

## 7.5 三级Cache支持下的物理内存访问

下图为通用的高速缓存存储器（Cache）组织结构示意图：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps217.jpg) 

图7.7 三级cache

Intel Corei7处理器采用的就是三级Cache支持下的物理内存访问。已经通过虚拟地址得到了物理地址，物理地址有52位，0-5位是CO（Cache偏移量），6-11位是CI（Cache索引），12-51位是CT（Cache标记），我们先利用CI找到对应的Cache组，如CI=0，就找编号为0的Cache组，每一个Cache组中有8个Cache行，我们找到标记为等于CT的Cache行，如果这个行存在且有效位为1，则缓存命中，取出偏移量为CO的字节，并传递给CPU。如果缓存未命中，则继续到L2中寻找，L2未命中到L3中，L3未命中到主存中寻找。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps218.jpg) 

图7.8由物理地址通过cache加快访问主存

(1) 根据PA、L1高速缓存的组数和块大小确定高速缓存块偏移（CO）、组索引（CI）和高速缓存标记（CT），使用CI进行组索引，对组中每行的标记与CT进行匹配。如果匹配成功且块的valid标志位为1，则命中，然后根据CO取出数据并返回数据给CPU。

(2) 若未找到相匹配的行或有效位为0，则L1未命中，继续在下一级高速缓存（L2）中进行类似过程的查找。若仍未命中，还要在L3高速缓存中进行查找。三级Cache均未命中则需访问主存获取数据。

(3) 若进行了(2)步，说明至少有一级高速缓存未命中，则需在得到数据后更新未命中的Cache。首先判断其中是否有空闲块，若有空闲块（有效位为0），则直接将数据写入；若不存在，则需根据替换策略（如LRU、LFU策略等）驱逐一个块再写入。

 

## 7.6 hello进程fork时的内存映射

当fork函数被父进程（shell）调用时，内核为新进程（未来加载执行hello的进程）创建各种数据结构，并分配给它一个唯一的PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps219.jpg) 

图7.9 进程共享对象

fork创建新进程后，因为新进程是父进程的一个副本，为了提高速度，两个进程的虚拟内存映射的是同一块物理内存，只不过是写时复制的。也就是说当新进程的某一虚拟页发生了更改，与父进程的虚拟页不同时，再将新进程被更改的虚拟页映射到另一个块物理页上。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps220.jpg) 

图7.10 私有的写时复制对象

## 7.7 hello进程execve时的内存映射

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps221.jpg) 

图7.11 Linux进程的虚拟内存

execve加载和运行hello程序会经过以下步骤：

1.删除已存在的用户区域：这里指在fork后创建于此进程用户区域中的shell父进程用户区域副本。

2.映射私有区域：为hello程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射到hello可执行文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello文件中。栈和堆区域也是请求二进制零的，初始长度为零。

3.映射共享区域：hello程序与一些共享对象或目标链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。

4.设置程序计数器（PC）：execve做的最后一件事就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。

 

## 7.8 缺页故障与缺页中断处理

DRAM缓存不命中称为缺页。缺页故障属于异常类别中的故障，是潜在可恢复的错误。

缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已经被修改了，内核会将其复制回磁盘。随后内核从磁盘复制引发缺页异常的页面至内存，更新对应的页表项指向这个页面，随后返回。

缺页异常处理程序返回后，内核会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件，此次页面会命中。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps222.jpg) 

图7.12 缺页故障处理

程序开始执行后, Linux将根据需要换入代码和数据页面，MMU在试图翻译某个虚拟地址A时时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后执行下面的步骤：

\1. 判断虚拟地址A是否合法，缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。

\2. 判断试图进行的内存访问是否合法，比如这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的，这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的。如果试图访问的操作是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。

\3. 内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送A到MMU。这次，MMU就能正常的翻译A，而不会再产生缺页中断了。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps223.jpg) 

图7.13缺页处理状况

## 7.9动态存储分配管理

动态内存分配管理使用动态内存分配器来进行。动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可以用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配的状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。

分配器有两种风格——显式分配器和隐式分配器。C语言中的malloc程序包是一种显式分配器。显式分配器必须在一些相当严格的约束条件下工作：①处理任意请求序列；②立即响应请求；③只使用堆；④对齐块（对齐要求）；⑤不修改已分配的块。在以上限制条件下，分配器要最大化吞吐率和内存使用率。

这里简要介绍一些组织内存块的方法：

(1) 带边界标签的隐式空闲链表分配器管理：

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps224.jpg) 

图7.14隐式空闲链表组织堆

带边界标记的隐式空闲链表的每个块是由一个字的头部、有效载荷、可能的额外填充以及一个字的尾部组成的。在隐式空闲链表中，因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。其中，一个设置了已分配的位而大小为零的终止头部将作为特殊标记的结束块。当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器有三种放置策略：首次适配、下一次适配合最佳适配。分配完后可以分割空闲块减少内部碎片。同时分配器在面对释放一个已分配块时，可以合并空闲块，其中便利用隐式空闲链表的边界标记来进行合并。

(2) 显式空闲链表：

显式空闲链表是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。如堆可以组织成一个双向链表，在每个空闲块中，都包含一个前驱与一个后继指针。可以采用后进先出的顺序维护链表，将最新释放的块放置在链表的开始处，也可以采用按照地址顺序来维护链表，其中链表中每个块的地址都小于它的后继地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps225.jpg) 

图7.15双向空间显式链表

(3) 分离的空闲链表：

将块按块大小划分大小类，分配器维护一个空闲链表数组，每个大小类一个空闲链表，减少分配时间同时也提高了内存利用率。C语言中的malloc程序包采用的就是这种方法。

 

红黑树等树形结构：按块大小将空闲块组织为树形结构，同样有减少分配时间和提高内存利用率的作用。

常见的放置策略：

l 首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。

l 下一次适配：类似于首次适配，但从上一次查找结束的地方开始搜索。

l 最佳适配：选择所有空闲块中适合所需请求大小的最小空闲块。

 

## 7.10本章小结

 

本章介绍了hello的存储器地址空间、intel 的段式管理、hello的页式管理，在指定环境下介绍了VA 到PA的变换、物理内存访问，还介绍 hello 进程 fork 时的内存映射、 execve 时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。

我们可以看出现代计算机系统为提高内存存储效率和使用率以至程序运行的效率使用了大量的机制和技术。

 

***\*（第7章 2分）\****

# ***\* \*******\*第\*******\*8\*******\*章\**** ***\*hello的IO管理\****

## 8.1 Linux的IO设备管理方法

设备的模型化：所有的 I/O 设备都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行，如/dev/sda2文件是用户磁盘分区。

设备管理：将设备模型化为文件的方式允许Linux内核引入一个简单、低级的应用接口，称为Unix IO，这使得所有的输入和输出都能以一种统一且一致的方式来执行。

## 8.2 简述Unix IO接口及其函数

***\*Unix\**** ***\*I\*******\*/\*******\*O接口：\****

（1）打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息，应用程序只需要记住这个描述符。

（2）shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符0）、标准输出（描述符1）和标准错误（描述符2）。头文件< unistd.h> 定义了常量STDIN_FILENO、STOOUT_FILENO和STDERR_FILENO,它们可用来代替显式的描述符值。

（3）改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。

（4）读写文件：一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k>=m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测这个条件。在文件末尾处并没有明确的“EOF符号”。写操作从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。

(5) 关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

***\*相关函数：\****

(1) open函数：

函数原型：int open(char *filename, int flags, mode_t mode);

open函数打开一个存在的文件或创建一个新的文件，将filename转换为一个文件描述符，并返回描述符数字（总是进程中未打开的最小描述符）。flags参数指明进程如何访问文件（O_RDONLY只读打开、O_WRONLY只写打开、O_RDWR可读写打开），mode参数指定新文件的访问权限位。

(2) close函数：

函数原型：int close(int fd);

fd是需要关闭的文件描述符，close函数关闭这个打开的文件，关闭一个已关闭的描述符会出错，返回操作结果（0表示正常关闭，1出现错误）。

(3) read函数：

函数原型：ssize_t read(int fd, void *buf, size_t n);

read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。

(4) write函数：

函数原型：ssize_t write(int fd, const void *buf, size_t n);

write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。失败返回-1，否则返回写入文件的字符数。

## 8.3 printf的实现分析

vsprintf函数将所有参数内容格式化后存入buf，返回格式化数组的长度。write函数将buf中的i个元素写到终端。从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。

 

***\*p\*******\*rintf\*******\*函数：\****

int printf(const char *fmt, ...)

{

  int i;

  va_list arg = (va_list)((char *)(&fmt) + 4);

  i = vsprintf(buf, fmt, arg);

  write(buf, i);

  return i;

}

printf函数调用了vsprintf函数，最后通过系统调用函数write进行输出；va_list是字符指针类型；((char *)(&fmt) + 4)表示...中的第一个参数。

***\*v\*******\*sprintf\*******\*函数：\****

int vsprintf(char *buf, const char *fmt, va_list args)

{

  char *p;

  chartmp[256];

  va_listp_next_arg = args;

  for (p = buf; *fmt; fmt++){

​    if (*fmt != '%'){

​      *p++ = *fmt;

​      continue;

​    }

​    fmt++;

​    switch (*fmt){

​    case 'x':

​      itoa(tmp, *((int *)p_next_arg));

​      strcpy(p, tmp);

​      p_next_arg += 4;

​      p += strlen(tmp);

​      break;

​    case 's':

​      break;

​    default:

​      break;

​    }

​    return (p - buf);

  }

}

vsprintf接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出写入buf给系统调用write输出时使用。

***\*w\*******\*rite\*******\*系统调用：\****

write: 

mov eax, _NR_write

mov ebx, [esp + 4]

mov ecx, [esp + 8]

int INT_VECTOR_SYS_CALL

给寄存器传参，随后调用中断门int INT_VECTOR_SYS_CALL，通过系统来调用sys_call实现输出这一系统服务。

***\*s\*******\*ys_call\*******\*：\****

call save

push dword [p_proc_ready]

sti 

push ecx        //ecx中是要打印出的元素个数

push ebx        //ebx中的是要打印的buf字符数组中的第一个元素

call [sys_call_table + eax * 4]

add esp, 4 * 3

mov [esi + EAXREG - P_STACKBASE], eax

cli

ret

sys_call显示格式化了的字符串。它将串里面的字节，从寄存器里面通过总线，复制到显卡显存里面，存放Ascll码。字符显示驱动子程序将通过ASCII码在字模库中找到点阵信息将点阵信息存储到vram中。显示芯片会按照一定的刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。最后我们的打印字符串就显示在了屏幕上。

## 8.4 getchar的实现分析

当程序运行至getchar函数时，程序通过系统调用read等待用户键入字符并按回车键（通知系统输入完成）

getchar实现：

\#include "sys/syscall.h"

\#include <stdio.h>

int getchar(void)

{

  char c;

  return (read(0,&c,1)==1)?(unsigned char)c:EOF

  //EOF定义在stdio.h文件中

}

getchar函数调用read函数返回字符。read函数的第一个参数是描述符0,代表标准输入。第二个参数是字符c的地址，最后一个参数是1，代表读入一个字符。read函数的返回值是读入的字符数，如果为1说明读入成功，那么直接返回字符，否则说明读到了buf的最后。read函数同样通过sys_call中断来调用内核中的系统函数。键盘中断处理子程序会接受按键扫描码并将其转换为ASCII码后保存在缓冲区。然后read函数调用的系统函数可以对缓冲区ASCII码进行读取，直到接受回车键返回。这样，getchar函数通过read函数返回字符，实现了读取一个字符的功能。

getchar有一个int型的返回值。当程序调用getchar时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar从stdio流读入一个字符。getchar函数的返回值是用户输入的第一个字符的ascii码,如出错返回-1,将用户输入的字符回显到屏幕。如果用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取。后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键。

## 8.5本章小结

本章阐述了Linux操作系统的I/O设备管理方法——设备被模型化为文件并使用Unix I/O接口进行文件操作，最后还分析了printf函数和getchar函数的实现,体会到Unix I/O接口在Linux系统中的重要作用。标准I/O函数的实现都调用了系统的I/O函数，通过中断指令将程序控制权交给系统内核，进行相应的中断处理，然后对硬件进行相应操作。

 

***\*（第8章1分）\****

#  

# ***\*结论\****

用计算机系统的语言，逐条总结hello所经历的过程。

你对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。

一、 hello程序历程总结

hello.c源代码文件通过预处理器，删除了注释，插入库函数，替换宏定义，得到了调整、展开后的ASCII文本文件hello.i；编译器对hello.i进行词法、语法语义分析，加入伪指令和注释，得到汇编代码文件hello.s，；汇编阶段，汇编器将hello.s生成包含各种重定位条目、符号表、数据段、代码段等区段ELF格式的文件hello.o；链接阶段，hello.o通过链接器与其他所需的可重定位目标文件、共享库链接，对符号进行重定位，最后生成可执行目标文件hello。

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps226.png) 

进程是程序运行的载体。用户在shell中键入hello命令，shell解释用户的命令，找到hello可执行目标文件并为其执行fork子进程；子进程调用execve完成在其上下文中对hello程序的加载，hello开始执行；hello进程接受内核的进程调度，（调用sleep后内核进行上下文切换，调度其他进程执行），操作系统内核为hello分配时间片，当时间片使用完会进行上下文切换运行其他进程；

![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps227.png)![img](file:///C:\Users\王多鱼\AppData\Local\Temp\ksohtml43260\wps228.png) 

hello运行时，hello进程享有CPU资源执行自己的逻辑控制流；可能发生缺页异常等故障、系统调用等陷阱以及接收到各种信号，这些都需要操作系统与硬件设备协同处理；hello执行的过程中会访问其虚拟空间内的指令和数据，需要借助各种硬件（包括寄存器、CPU、MMU、TLB、三级Cache、四级页表等来进行内存的翻译、访问和加速）、软件机制来快速、高效完成；hello运行时要调用printf、getchar等函数，需要使用Linux系统的I/O设备管理、Unix I/O接口，printf函数会调用malloc向动态内存分配器申请堆中的内存；

hello进程运行结束后，父进程shell会进行回收，内核也会清除在内存中为其创建的各种数据结构和信息。

二、 感悟与创新理念

计算机系统的设计和实现大量体现了抽象的思想：文件是对I/O设备的抽象，虚拟内存是对主存和磁盘设备的抽象，进程是对处理器、主存和I/O设备的抽象，进程是操作系统对一个正在运行的程序的抽象；

完成本次论文让我看到简单的C代码hello程序从编译到执行的全过程信息，计算机系统课程引领我从程序员的角度系统地认识计算机系统的各种机制、设计和运行原理。我会在未来继续深入学习相关知识并在今后的具体实践中不断尝试使用和创新。

通过csapp课程，我了解了计算机系统的基本概念，包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库，以及用户应用等，以程序员的视角感知了计算机系统，以成为一名优秀的程序员为目标。

同时通过本课程学习也了解了世界上有很多优秀的人在学习计算机知识，学习了本门优秀的海外引进课程，也告诉我要多利用视频和经典教材学习海外计算机名校的课程，不断成长才不会让自身的成长和国内顶尖高校和海外名校的学生越差越远。

***\*（结论0分，缺失 -1分，根据内容酌情加分）\****

# ***\* \*******\*附件\****

列出所有的中间产物的文件名，并予以说明起作用。

| 文件名称            | 作用                                     |
| ------------------- | ---------------------------------------- |
| hello.i             | hello.c经预处理得到的ASCII文本文件       |
| hello.s             | hello.i经编译得到的汇编代码ASCII文本文件 |
| hello.o             | hello.s经汇编得到的可重定位目标文件      |
| hello               | hello.o经链接得到的可执行文件            |
| hello_o_elf.txt     | hello.o经readelf分析得到的文本文件       |
| hello_o_objdump.txt | hello.o经objdump反汇编得到的文本文件     |
| hello_elf.txt       | hello经readelf分析得到的文本文件         |
| hello_objdump.txt   | hello经objdump反汇编得到的文本文件       |

 

***\*（附件0分，缺失 -1分）\****

 

# ***\* \*******\*参考文献\****

***\*为完成本次大作业你翻阅的书籍与网站等\****

[1] 《深入理解计算机系统》

[2] ELF文件头结构

https://blog.csdn.net/king_cpp_py/article/details/80334086

[3] 内存寻址分段管理机制

https://blog.csdn.net/gatieme/article/details/50647000

[4] printf函数实现的深入剖析 

https://blog.csdn.net/zhengqijun_/article/details/72454714

[5] read和write系统调用以及getchar的实现

https://blog.csdn.net/ww1473345713/article/details/51680017

[6] 虚拟地址 、逻辑地址、线性地址、物理地址

https://blog.csdn.net/rabbit_in_android/article/details/49976101

 

***\*（参考文献0分，缺失 -1分）\****